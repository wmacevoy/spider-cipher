/*------------------------------------------------------------------------------
Parametric Easy-Print D8
Version 1.0

Copyright 2017 HalfwitTomfoolery
https://www.youmagine.com/halfwittomfoolery/designs

Licensed as Creative Commons Attribution version 4.0 or later.
https://creativecommons.org/licenses/by/4.0/
------------------------------------------------------------------------------*/

// Full diameter of die from corner to corner.
diameter = 152.4;

// Amount to round corners and edges.
rounding = 2;

// Name (and, optionally, style) of font to use.
// For information on font styles, see:
// https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Text
font = "Arial";

// Depth of lettering, scaled by font size.
letteringdepth = 0.08;

// Font size, in fairly arbitrary units.  Just play with it until you get what you want.
fontsize = 0.4;

// Distance to inset numbers into faces of the die (arbitrary units).
insetamount = 0.08;

// More negative == narrower text.  More positive == bolder text.
boldness = 0;

// Smoothness.  Higher produces a better quality model.
$fn = 32;

// Number of steps to add in the text bevelling process.
// More == better quality, but it takes vastly more time to render.
textbevelsteps = 30;

/*------------------------------------------------------------------------------
Number text
--------------------------------------------------------------------------------
The text of each number is configurable.  This allows you to use (depending on
the font) roman numerals, Braille, symbols, etc.  It also allows you to tune the
balance of numbers as you wish to try to better balance the fairness of the die.

Two examples are given here - an unshuffled version and a shuffled version.
------------------------------------------------------------------------------*/

// Unshuffled:
/*numbers = [
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8"
    ];*/
/* Pairwise shuffled using the following crude Python program:
import random;

n = [
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8"
  ];

for i in range(50):
  r = random.randrange(1,6);
  t = n[r];
  n[r] = n[7 - r];
  n[7 - r] = t;

print(n);

The idea behind doing this pairwise is that if there are any balance issues introduced due to the slicer, at least each pair should be roughly evenly balanced, which I would think would help reduce the possibility of bias toward the low or high end of the [1..8] range.
*/
numbers = [
        "1",
        "7",
        "3",
        "5",
        "4",
        "6",
        "2",
        "8"
    ];


/*==============================================================================
END TUNABLE PARAMETERS

From here on, it's mostly just functional code.  Play at your own risk.
==============================================================================*/

radius = (diameter / 2) - rounding;
corners = [
        [radius, 0, 0],
        [-radius, 0, 0],
        [0, radius, 0],
        [0, -radius, 0],
        [0, 0, radius],
        [0, 0, -radius]
    ];

// Amount the text has to be scaled up to go from being placed on a unit cube to our current cube.
scalingfactor = 1.15 * (radius + rounding);

// Z position adjustment of text to take into account boldness.
flatsurfaceheightunscaled = (1.01 + (-boldness * 0.03)) / 2;

// This module generates bevelled text using progressive stepped insetting/outsetting.
module bevelledtext(t, font, fontsize, insetamount, depthamount)
{
    union()
    {
        insetdistance = insetamount * fontsize;
        depth = depthamount * fontsize;
        
        for(s = [0:textbevelsteps])
        {
            translate([0, 0, (-(s + 0.5) / textbevelsteps + 0.5) * depth])
            {
                linear_extrude(depth / textbevelsteps + 0.01)
                {
                    offset(r = -((s * 2 - textbevelsteps) / textbevelsteps) * insetdistance)
                    {
                        text(text = t, font = font, size = fontsize, halign = "center", valign = "center");
                    }
                }
            }
        }
    }
}

// Calculate the difference of the cube and all of the text.
rotate([-atan(sin(45) / 1), 0, 0])
{
    rotate([0, -45, 0])
    {
        difference()
        {
            // Cube
            // Generated by adding spheres at vertices, then taking the hull.
            hull()
            {
                for(p = corners)
                {
                    translate(p) { sphere(r = rounding); }
                }
            }
            
            // Add the text
            scale([scalingfactor, scalingfactor, scalingfactor])
            {
                union()
                {
                    angles = [
                            [45, atan(sin(45) / 1), 30],
                            [45 + 90, atan(sin(45) / 1), 30],
                            [45 + 180, atan(sin(45) / 1), 30],
                            [45 + 270, atan(sin(45) / 1), 30]
                        ];
                    for(i = [0 : 3])
                    {
                        rotate([angles[i][0], 0])
                        {
                            rotate([0, angles[i][1]])
                            {
                                rotate([0, 0, angles[i][2]])
                                {
                                    // Add the top number.
                                    translate([0, 0, flatsurfaceheightunscaled])
                                    {
                                        bevelledtext(numbers[7 - i], font, fontsize, insetamount, letteringdepth);
                                    }
                                    
                                    // Add the bottom number.
                                    rotate([180, 0, 0])
                                    {
                                        translate([0, 0, flatsurfaceheightunscaled])
                                        {
                                            bevelledtext(numbers[i], font, fontsize, insetamount, letteringdepth);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
